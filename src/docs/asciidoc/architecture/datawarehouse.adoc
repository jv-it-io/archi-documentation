== datawarehouse

=== Send Data to datawarehouse
As we have multiple application that need to distributing their data to DWH, we need to find a mechanism to ensure
this collect of data.

We use rabbit mq for sending information to DWH. A dedicated service send the data to the DWH database and so that
the data for the corresponding system is available for processing in DWH.

==== Outbox pattern
The primary goal of the Outbox Pattern is to ensure that updates to the application state (stored in tables) and
publishing of the respective domain event is done within a single transaction
https://debezium.io/blog/2020/02/10/event-sourcing-vs-cdc/


===== Event Sourcing
Event Sourcing is a solution that allows software to maintain its state as a journal of domain events.
As such, taking the journal in its entirety represents the current state of the application.
Having this journal also gives the ability to easily audit the history, and to time travel and reproduce errors
generated by previous state.

Event Sourcing implementations usually have these characteristics:

* Domain events generated from the application business logic will add new state for your application

* State of the application is updated via an append-only event log (a journal) that is generally immutable

* Journal is considered the source of truth for the lifetime of the application

* Journal is replayable to rebuild the state of the application at any point in time

* Snapshotting mechanism for the journal to speed up recreating the state of an application

image::../diagrams/figureEventSoucing.png[]

===== Change Data Capture

Change Data Capture (CDC) is a solution that captures change events from a database transaction log
(or equivalent mechanism) and forwards those events to downstream consumers. CDC ultimately allows application state
to be externalized and synchronized with external stores of data.

Change Data Capture implementations usually have these characteristics:

* External process that reads the transaction log of a database with the goal to materialize change events from those transactions

* Change events are forwarded to downstream consumers as messages

* A durable message broker is used to forward events

* The ability to replay events from the datastore transaction log and/or message broker for as long as the events are persisted


image::../diagrams/CDCImplementation_2.png[]

A standalone CDC process to capture and forward events from the transaction log to a message broker
Then forwards events to consuming applications via a message broker


==== using Javers event
The distributed data for DWH can come from the original data application. By using the Javers framework (see persistence layer part)
we can base our distribution on the event commit from the Javers collection.
So that we can get more specific information on the event (changed properties, operation type, ID...)

a big challenge by using this framework is the operation that concern embedded data. In this case Javers, give
a reference state and non the object itself in the metadata of the event.

==== Version data
For some reason a data structure can change during the life of the application. It is important to know what is the current
version of data in the datawarehouse.

The idea is to give a version number inside the data

option 1 : give a incremental number version in the data. Each new deploy of the application that include a structure change
increment the version on the data.

option 2 : give a version number based on the version number of the application. Each new release of the application give with
a change in the version of the data.

that gives the possibility to know what change has been made on the data structure between two version of the application.

=== Read data on datawarehouse
==== Option1 : behind specific Âµservice with rest/rabbit

(+) isolation & reuse

(-) No possibility to replay event. Request to manage the exception on the side of the application.

==== Option2 inside application with specific Read Only Model
CQRS (Command Query Responsibility Segregation) is a pattern to create alternative representations of data,
known as projections, for the primary purpose of being read-only, queryable views on some set of data.
There may be multiple projections for the same set of data of interest to various clients.

The Command aspect to CQRS applies to an application processing actions (Commands) and ultimately generating
domain events that can be used to create state for a projection.
That is one reason why CQRS is so often associated with Event Sourcing.

image::../diagrams/CQRS.png[]


(+) CQRS for report operation

(-)  possibility of failure to update the CQRS projections if there is an error with the application.
This could result in missing data, and it may be difficult to recover that data without proper compensating actions
built into the application itself.
